{"nodes":[{"block_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","block_type":1,"children":["TFJJdU41no1xWVxfFkecUr7mnUe","UJCrdCfaYoSzg5xgUaLcHV1NnTg","RGCNdUl8woqqRJxV3KjcZbSpnKe","HsK5d3C06ohh4DxqE6xcGGEXnAh","Q727dkBQDoFJ1fx2dRKcWZBPnkh","Nzn4dAxfsosYp7xPtg9cXds2nXg","PKUCd1cXMojkYrxGJvxcnZYanSe","Zp6KdA964oxyaAxobW3cLq2GnRh","C1OJd8LU1o3eh7xPcGYcGzy5nyt","UoCTd8fM4oghLuxw4JMcqMDQnec","C1O8dvdOQoMPOYx2cqWcrLgJnRc","G96WdKjXMoXTRCx0mlzcCwOtnLS","ZMkQdXGgQosQ3MxexfEcsYMwnQd","EAw2dCHOWoSn8Wx8N7Kck9G4nKc","AJSFdLfktocBuVxGJ5qcNtUFnxf","FhpMdYsjKoeU0Gxl18acT5OknKh","E9WtdHMNYoaHeUxuw6Mc5T0xncd","Oge2dvvP4ol0n7xnvCjcZF7SnSi","Shbsd0AoToRmDgxgv40cQM69nId","O4i3d3FlCo0uHRx0Uj1cVMiTnfe","QHtedeXSAo122KxXgxqc7Cu5nMc","UkAtdeJquoCCrsx1vdic5ceinO7","Re29dhTruoyEENxux06cfsi8nqg","D8Qjdgr7lodE5ExcdICcPWSonad","Y82Ld9fQ7oP2H2x1JmNcyWpfnVc","MB5QdOUyMo2BHkx5WfqcR6A5nSg","PYh2dmSiBow5aNx9oAXcw397nLe","Utt4dAGi4o63AAxZlb0cLdJSnAb","NQ8UdAyISo6wkwxgUvmc4wuKnye","PsEWdpST0oHmCFxeF34clNECn7f","Tj5JdnUdhoMBPUxhpHtcDRmCnSb","NgGGdRRm4o5SHpx2UrZcVpyMnPR","Bnrcdeo2poeNWvxdJnQcRkTwnbe","PUhxd3ygRoW350xtyJAcBF6Qnyd","YSePdLRo6ou6VexiEJacipK3nad","I0Wxd8TnqopkTDxaOUtcOF0unHb","Cn7XdSj7ZoZOyRx09HLcIk9incc","UY7mdWLkUoE7AgxJbUKculWhn6b","LnOtdWaGroevv5xp4JIcqHtcnSg","S5ngdBLUdoiwJAxS1FBcVrWHnOh","ZFK2dmQoioHtQ8xsCF4cAg34ndd","AYoid5garoFCOCxsMWBc1HzPn9f","YeZydDnLyo4VWCx8Kpjce8lBn7d","JtxAdLUgcoWb7UxSEqxcy02kn7b","Lw5ldE75BoWcRixHOcDcl8denhb","XmxwdBwCEoysprxZpXNcKCBenAb","JtFNdbvxboeQN0xt1KMc4jqhnvc","Clswd3GH3oVfhgxzXxCcKTWenvf","Bd0Id3SpjoETfDxx5wKc51oOntb","TMUWd70zHojsjJxzJrQcEwS3nbe","Ylkkd0skNobaKAxaz9ocBUUOn9b","R70Ud2FieoOewCxHdwvcRLEgnvh","ZNUDdAwFZoUZ37xgyu9cNdY1nGd","W6IcdJrqyoMvxbxQJFocYoOmnWf","AJYud2s69oA2o3xffKcciLdwnMd","BphXdPNETos2HAx1S0ycC8OXnhc","UigRdNz0DoRIg5xjstRcUCDdnie","KL1odGJJWoIIz4xRiYCcGihCnOg","K4i8dXn7QoYBPjxo6BkcRByAndh","WrJzdHppEoKvH3xt8MIcMBZanYb","MpX6deLuDo7l2jxfV6Ac3ogJnqf","RtWkdaOvnoqxuMxa36ccPGMunQc","J4s1dg1CdoAZLdxA9cKc68vAnHb","Ja36diP9JoVoT4xMJ8Kc5UFqnGd","IivrdnnEXonq3GxELNzc3uGQn8f","AL1WdjLEIo5QYUx2FBFcrUlxn1d","UMeDdFOVioAMrHxSH6AcNi8uncc","NmBZdPVecoZ6GRxIWVjcf1s1nnj","S4O7dV6ZRo6Ihix4ti5cSqvonKd","UTvQd8pzeopBSExFgC7cyEDCnlh","G0LtdCaFhotz72xUvqrcUTiBnAn","HUMvdRoQEo6XhDxyBHucrS2Rncd","YSbtdP21boDQ1wxWl2TcZieDnAe","QAM0dg73ZofcLPxsfNZcHHPwnYe","T8jldF80GocD5zx3IqUcZsHlnuf","YnDHd8FXwonUskx7ey8cb2sCnLc","ZAODdb0FYo1WHkxgcD4cXtCWnqf","IrWhd0R4io23RqxnpQhcaUnunMc","FXOJdYMrGoOAWmxHvnlchJ71ndU","MytpdsJ20oKysIxO7KeczMncnMe","FraNdqcZ1oj0rYxQTTcca2e8nug","CSY4dhNnro72jKxheVJciIaenj7","VqThdUnrRobit7xn20acPUWLnrb","CLiXdJ8yAopMWpxHr4UczDaKnLf","W6DydckbXoKqskx8SOEcvwlRnOb","Oue9dgJaKoOMbrxpCl8cncUMnNp","CSNDdrkqjoVakKxyW0pcltD4nJb","GytAdjXCQoh1rwxFKpscCRGqnQb","MNR2dpWX1o5oOBxR8Vzc4XY1nOb","LGTtdeqI1o4WnwxPcSpc3W64nFf","XdZqdTJOUouNngxBr6aczh8VnV5","VlKndadxNoauFSxVBkgcQGAgnge","EZCFdgKsloP6AVxJxgncODIinFg","CfhKdJQ1yo0ZdaxRH48cHK99nmc","CiFBdEvtsoU26Mxv9BBcYExKnib","E64Td5Qhrot4SWxOduxcIH9GnCd","BWbSdY8q6oqNjDx4lpvcgkOWn7g","YhOZd2C2qofIZixwuFDceupznMb","EHe7dgbbcoPZTMxQY2JcTWFpnZr","SXhhdrv6eoOqOqx5T0fcgdLYntb","M9xFd7KtUoG5v9xvoS4cP1WAnxd","Nsg9dnf78oomXRxq8QVcj7J2nrb","Gux4dDqPboGIdWxL13hc2ZxtnZc","QXludKHaWoRbioxUXLccs2ELnMc","R0xLdZrMBotGCMxYYHScpAAknGb","MZWgdqK0fo7hawxkQxFclHHnnsb","Jm3gdyJGsomZi1xIWDScr8YInYr","JbqOdAka1oQ9odxcdfbcLmtEnDe","DUqZdvg2Qokf4kxhBXjcUiRWn2b","TWxld3qPvorDyTxbspScddBKn6b","I8mbdO3vZoIM7QxGcW2chTrhnwc","Z7C6df4JqoNoRPxfuzhczsFcnXd","Hk5gdPuXoo5YRMxdNqWcH35Cnxd","RUHRdOFh6oEypBxdTB5cjbTXnRh","SOPJd729YowkMLxJsvVcjBeAnBd","OHjoduZboobeW1x199PceUq9nyf","Rf8qdKfy9oL5qwxlOg3c4AjcnVg","GxDCd9OnhowNxrx2IRccO3ann9D","WUDpdZoOfo9BTgx6UO4ckRgPnDg","SGfWdwJDEotkVMxKHLvcUmgSnqf","KwYmdrjMEoKsRyxfl1NcOXdOnKd","GxMgdSgXrovEz2xww1fcNJnpn6f","Ak37ddzz1op0jwxWas8cSEJWnCb","QIBBdZGfNoQfazxCQy6crx0lnEp","Awpbdcid7oFmOlxcjcbckJJin8b","SZfdd6qfvoDkYnxZIUZcuDHonfe","HC0XdjsYEojAdfxyPOYc8FTZnqf","LIepdNispo7lstxwmqHc8Z9On4f","K6IEdMOI4oRI6TxAEFmcGew8nGc","FqKgd4XCOogOLOxiRBYcXm6gnMd","J0y7dSZo9oOIDOxjrXQcOZlXnra","MZ0dd85PEoOhvgxiCUzcVqLJnhf","VGoidQ7DAoCklbxdCoVcdh0KnXd","MVSRdoUQCoT1O4xDyR9cuYtmnme","OsOFdOto2oKGPuxP5ERcbD76nSe","ST8LdERqfoH04hxP4vbclEdWnhT","F8RRdHQHBo8pYFxbOa7ccti4n9g","WjAnd9UZnoTG0LxPCOfcwAeDnwf","STq7dfO5uodsYPxBq7Nc4F8inQe","XGvydkqqooB5dZx1hdKc8UVRnlw","W89ydvP9loMzkexZuRrcJPXmnvd","JTUIdlAtool5ZLxFKP4c755Nnnf","EctdddhOFo7ZKOxBVP4cffLenii","YnuNdiGU4o2U6sxIgaQcLwUznOe","WaXudSJ0koy1vMxmxxkcmCaln0r","WzVrdGtIzoPLLwxKUnmcYyJdnAe","XGBNdmfvlo3kumxmWEqcYOtynsg","A7cwdGlZ2oIWuuxHSWscJok3nkg","PLI0d8MpVoAqK2xNaAXc0bMMn1G","F7R0dwA1mofA6qxevTscLAtgnKE","ERCfdxA2zo9dfRxYQXycQZKVnNd","FOTTdUqOWoAXWgxc2nMcH8tgn84","TYIbdGwSQow2Chx9y9Sc5LYlnsh","UI9MdsFmZosPE4xxU5ncVUvZnac","BgXWdki6foXAX0x5xpIcLnxZnlb","KwVsdSVpGowsQSxjZQUcnsMWnBc","G88idE4sVowoshxTriockgHjnCc","MAnRdLkBdo2ufrx00eUcOdMKntb","R7qQdXCJcoxJRjxxK4xcISKlnZb","L77QdxVP6o0gWcx7tH1c8YFGn1d","E4ZudwfU3oMRmqx4sPvconZFnXg","RFAddEIp9ohS4YxtilNctrconU1","SUxmd51sZoEilbxBYmuciIVTn3e","UBBudTLg5oybyCxh2ANcKe8wnth","Q23Od6lXVoIGGSxgI5IczFr4nYK","KvnFdRmpjooy1SxEZmycF8Lhnnp","DqNrdC6mXoe8MIx80HmcBWbMnDd","DTbGd1X9Xo75E7xis1acSy9KnWc","YBMQdLqp7ofvTnxrZdicyN35nge","EmqedKpmjoyzKSxDZZLcz2a9nDb","AXxrdPKNOouHqoxzqUucOcmsnhd","R6OzdxWWJoTA3axty7GctutOn9g","FtIZdiRCooGFaExsbGQc5RLznrb","KYAjdSW56o8mgWxpAPHcTRTen6b","Jjs7dfjHTothFSxQM6qco2HknSh","BmTiduQoboeD48x54t6cE02xnqh","OOVwdW8tQo8XKLxAcqGcUYzrnDg","XL7KdUVhpokW0gx0I0lc2peHnwf","FlDzdNhwGoloxLx96fDcgrcZnl3","OeEHdb8xCou6Vwx8DMncHdSJnDg","UvYudv3YJoa8gExXPXAcJ0bTnUc","C9okdmwFNoOYQoxaFL3cRggqn1c","REdadtgXwoKWk7xIPvDccMbqnmf","RFE2dKLcWoLLNvxFkrTccsMwnFf","V3modj4R7o4j2fx8Kkvc6yXEn5b","WuUmd7CBpoGaqyxK01RcCVMEnDd","QoAOdedSeoICYmxctb1c5YS4nST","Le6rd16zIoyGO0xVfTkc2LxwnAf","Zt31dKT8xoPBXIxJN2GcBhYknjd","EjITdi80Qo4ccsxW4QecJzrrnaf","AYQfdVJVzo5XgexAqr5c8yA6nXb","SDS2dxw1EodTAwxoInQc7tUOnag","Mh8ZdnT7GoOKxSxCLSqcL5penbh","JOIddD9sIoCtKSx4O4VcfnCbnQd","B6OFdfcj2oXWUfxXPgHcUky3nsi","XJuOd5CkJoodCOxshrQcK8Wwn3c","QMGDdKOOQoUgf1xmtC1c4n9snzd","YmpbdhivRoPXUvxAm2jcPHFWnrf"],"page":{"elements":[{"text_run":{"content":"Java基础","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1}},"parent_id":""},{"block_id":"TFJJdU41no1xWVxfFkecUr7mnUe","block_type":3,"heading1":{"elements":[{"text_run":{"content":"跨平台","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"UJCrdCfaYoSzg5xgUaLcHV1NnTg","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"Java程序被编译成字节码，JVM将字节码翻译为不同平台下的机器码，从而运行java程序。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"RGCNdUl8woqqRJxV3KjcZbSpnKe","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"跨平台已经不是 Java 最大的卖点了，各种 JDK 新特性也不是。目前市面上虚拟化技术已经非常成熟，比如你通过 Docker 就很容易实现跨平台了,Java 强大的生态才是。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"HsK5d3C06ohh4DxqE6xcGGEXnAh","block_type":3,"heading1":{"elements":[{"text_run":{"content":"JDK&JRE&JVM","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Q727dkBQDoFJ1fx2dRKcWZBPnkh","block_type":13,"ordered":{"elements":[{"text_run":{"content":"JVM是Java虚拟机，是Java程序运行的环境。负责将Java字节码（由Java编译器生成）解释或编译成机器码，并执行程序。提供了内存管理、垃圾回收、安全性等功能，使得Java程序具备跨平台性。解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"1"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Nzn4dAxfsosYp7xPtg9cXds2nXg","block_type":13,"ordered":{"elements":[{"text_run":{"content":"JDK是Java开发工具包，是开发Java程序所需的工具集合。它包含了JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如Java标准库和开发工具库）。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"PKUCd1cXMojkYrxGJvxcnZYanSe","block_type":13,"ordered":{"elements":[{"text_run":{"content":"JRE是Java运行时环境，是Java程序运行所需的最小环境。它包含了JVM和一组Java类库。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Zp6KdA964oxyaAxobW3cLq2GnRh","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"从 JDK 9 开始，就不需要区分 JDK 和 JRE 的关系了，取而代之的是模块系统（JDK 被重新组织成 94 个模块）+ jlinkopen in new window 工具 (随 Java 9 一起发布的新命令行工具，用于生成自定义 Java 运行时映像，该映像仅包含给定应用程序所需的模块) 。并且，从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"C1OJd8LU1o3eh7xPcGYcGzy5nyt","block_type":3,"heading1":{"elements":[{"text_run":{"content":"编译&解释&JIT&AOT","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"UoCTd8fM4oghLuxw4JMcqMDQnec","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"Java既是编译型也是解释性语言，默认采用的是解释器和编译器混合的模式","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"C1O8dvdOQoMPOYx2cqWcrLgJnRc","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"编译性：Java源代码首先被编译成字节码。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"G96WdKjXMoXTRCx0mlzcCwOtnLS","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"解释性：JVM中一个方法调用计数器(PC,解释的字节码的行数)，当累计计数大于一定值的时候，就使用JIT进行编译生成机器码文件。否则就是用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"ZMkQdXGgQosQ3MxexfEcsYMwnQd","block_type":27,"image":{"align":2,"height":359,"scale":1,"token":"VC0Wb88QvorYj4xgNhXcnpwTncf","width":811},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"EAw2dCHOWoSn8Wx8N7Kck9G4nKc","block_type":4,"heading2":{"elements":[{"text_run":{"content":"JIT","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"AJSFdLfktocBuVxGJ5qcNtUFnxf","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"传统java：代码->.class->jvm。给 Java 程序带来了一些性能问题，比如启动速度慢和运行时内存占用高等。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"FhpMdYsjKoeU0Gxl18acT5OknKh","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"JIT(Just in Time Compilation)属于运行时编译。是 JVM 在","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"程序运行时","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"动态地把热点字节码编译成机器码","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，让后续执行直接运行机器码，不用反复解释字节码，从而加快性能。HotSpot JVM","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"E9WtdHMNYoaHeUxuw6Mc5T0xncd","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"JVM 专门划出一块内存区域（属于堆外内存），用于存放 JIT 编译生成的本地机器码。仅在当前 JVM 进程生命周期内有效，进程结束后，Code Cache 中的内容会被释放，不会持久化到磁盘。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"Oge2dvvP4ol0n7xnvCjcZF7SnSi","block_type":4,"heading2":{"elements":[{"text_run":{"content":"AOT","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Shbsd0AoToRmDgxgv40cQM69nId","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"AOT(Ahead-of-Time Compilation，AOT Compilation)是提前编译/静态编译，在","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"程序运行前","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，就把 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"字节码编译成本地机器码","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，然后在编译阶段进行代码编译优化，消除冷启动，属于静态编译。AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。GraalVM ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"O4i3d3FlCo0uHRx0Uj1cVMiTnfe","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"编译产物通常是一个","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"动态链接库（.so/.dll/.dylib）","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 或特定格式的二进制文件。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"QHtedeXSAo122KxXgxqc7Cu5nMc","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"UkAtdeJquoCCrsx1vdic5ceinO7","block_type":3,"heading1":{"elements":[{"text_run":{"content":"基本类&包装类","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Re29dhTruoyEENxux06cfsi8nqg","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"D8Qjdgr7lodE5ExcdICcPWSonad","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"自动装箱有一个问题，那就是在一个循环中进行自动装箱操作的情况，如下面的例子就会创建多余的对象，影响程序的性能。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"Y82Ld9fQ7oP2H2x1JmNcyWpfnVc","block_type":27,"image":{"align":2,"height":75,"scale":1,"token":"OejebheX2obVXixmjNAcBOlmnQg","width":1020},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"MB5QdOUyMo2BHkx5WfqcR6A5nSg","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。缓存命中时，装箱或valueOf 不会产生新对象，但是new会。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"PYh2dmSiBow5aNx9oAXcw397nLe","block_type":14,"code":{"elements":[{"text_run":{"content":"//自动装箱\nInteger a = 10;\n//等价于\nInteger a = Integer.valueOf(10);\n\n//自动拆箱\nint b = a;\n//等价于\n","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"int b = a.intValue();","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"language":29,"wrap":true}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Utt4dAGi4o63AAxZlb0cLdJSnAb","block_type":3,"heading1":{"elements":[{"text_run":{"content":"面向对象","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"NQ8UdAyISo6wkwxgUvmc4wuKnye","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"面向对象是一种编程范式，它将现实世界中的事物抽象为对象，对象具有属性（称为字段或属性）和行为（称为方法）。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性，通过封装和继承可以更好地应对需求变化。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"PsEWdpST0oHmCFxeF34clNECn7f","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"Java面向对象的三大特性包括：封装、继承、多态","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"Tj5JdnUdhoMBPUxhpHtcDRmCnSb","block_type":12,"bullet":{"elements":[{"text_run":{"content":"封装：封装是指将对象的属性（数据）和行为（方法）结合在一起，对外隐藏对象的内部细节，仅通过对象提供的接口与外界交互。封装的目的是增强安全性和简化编程，使得对象更加独立。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"NgGGdRRm4o5SHpx2UrZcVpyMnPR","block_type":12,"bullet":{"elements":[{"text_run":{"content":"继承：继承是一种可以使得子类自动共享父类数据结构和方法的机制。它是代码复用的重要手段，通过继承可以建立类与类之间的层次关系，使得结构更加清晰。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Bnrcdeo2poeNWvxdJnQcRkTwnbe","block_type":12,"bullet":{"elements":[{"text_run":{"content":"多态：多态是指允许同一个行为（方法）在不同对象上具有不同表现形式。即同一个接口，使用不同的实例而执行不同操作。它使得程序具有良好的灵活性和扩展性。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"PUhxd3ygRoW350xtyJAcBF6Qnyd","block_type":4,"heading2":{"elements":[{"text_run":{"content":"抽象类&普通类&接口","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"YSePdLRo6ou6VexiEJacipK3nad","block_type":5,"heading3":{"elements":[{"text_run":{"content":"抽象类和普通类区别","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"I0Wxd8TnqopkTDxaOUtcOF0unHb","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"实例化：普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"Cn7XdSj7ZoZOyRx09HLcIk9incc","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"实现限制：普通类可以被其他类继承和使用，而抽象类一般用于作为基类/模板类，被其他类继承和扩展使用。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"UY7mdWLkUoE7AgxJbUKculWhn6b","block_type":5,"heading3":{"elements":[{"text_run":{"content":"抽象类和接口的区别","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"LnOtdWaGroevv5xp4JIcqHtcnSg","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"实现方式：实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"S5ngdBLUdoiwJAxS1FBcVrWHnOh","block_type":2,"children":["BSNvdRZnOo5qgHx3ZZrc2LL7nkc","J3k1dbIWPoBuqbxssFPcDd74nng","KKIDd0p6voU1duxdumoc5vBdnW4","WU0qdloqnoAvoHxXvImc11rpn8f"],"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"方法方式：接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"BSNvdRZnOo5qgHx3ZZrc2LL7nkc","block_type":2,"parent_id":"S5ngdBLUdoiwJAxS1FBcVrWHnOh","text":{"elements":[{"text_run":{"content":"接口可以包括的方法：","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"indentation_level":"NoIndent"}}},{"block_id":"J3k1dbIWPoBuqbxssFPcDd74nng","block_type":13,"ordered":{"elements":[{"text_run":{"content":"默认方法是在 Java 8 中引入的，允许接口提供具体实现。实现类可以选择重写默认方法。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"1"}},"parent_id":"S5ngdBLUdoiwJAxS1FBcVrWHnOh"},{"block_id":"KKIDd0p6voU1duxdumoc5vBdnW4","block_type":13,"ordered":{"elements":[{"text_run":{"content":"静态方法也是在 Java 8 中引入的，它们属于接口本身，可以通过接口名直接调用，而不需要实现类的对象。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"S5ngdBLUdoiwJAxS1FBcVrWHnOh"},{"block_id":"WU0qdloqnoAvoHxXvImc11rpn8f","block_type":13,"ordered":{"elements":[{"text_run":{"content":"私有方法是在 Java 9 中引入的，用于在接口中为默认方法或其他私有方法提供辅助功能。这些方法不能被实现类访问，只能在接口内部使用。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"S5ngdBLUdoiwJAxS1FBcVrWHnOh"},{"block_id":"ZFK2dmQoioHtQ8xsCF4cAg34ndd","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"访问修饰符：接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"AYoid5garoFCOCxsMWBc1HzPn9f","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"变量：抽象类可以包含实例变量和静态变量，而接口只能包含常量（即静态常量）。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"YeZydDnLyo4VWCx8Kpjce8lBn7d","block_type":2,"children":["SNprdp1ttoVsXqxhhjhcUZsEnac","Q5ddd1AbjoRDg8xvPj8c1yFAnQh"],"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"使用场景：","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"SNprdp1ttoVsXqxhhjhcUZsEnac","block_type":12,"bullet":{"elements":[{"text_run":{"content":"抽象类：是一种“","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"模板类","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"”，代表一类事物的","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"共性特征","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，用来被继承，不能直接实例化。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"YeZydDnLyo4VWCx8Kpjce8lBn7d"},{"block_id":"Q5ddd1AbjoRDg8xvPj8c1yFAnQh","block_type":12,"bullet":{"elements":[{"text_run":{"content":"接口：是一种“","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"行为规范","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"”或“能力契约”，表示一个类","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"能做什么","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，不管它是什么。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"YeZydDnLyo4VWCx8Kpjce8lBn7d"},{"block_id":"JtxAdLUgcoWb7UxSEqxcy02kn7b","block_type":4,"heading2":{"elements":[{"text_run":{"content":"静态变量和静态方法","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Lw5ldE75BoWcRixHOcDcl8denhb","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"静态变量和静态方法是与类本身关联的，而不是与类的实例（对象）关联。它们在内存中只存在一份，可以被类的所有实例共享。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"XmxwdBwCEoysprxZpXNcKCBenAb","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"静态方法可以使用任何访问修饰符。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"JtFNdbvxboeQN0xt1KMc4jqhnvc","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"静态方法不能调用非静态成员变量，因为类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。静态方法不支持重写（Override），但可以被隐藏（Hide）。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"Clswd3GH3oVfhgxzXxCcKTWenvf","block_type":27,"image":{"align":2,"height":1595,"scale":0.45595854922279794,"token":"ZckvbaMzVoA39kxISIgcYl53ntf","width":965},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Bd0Id3SpjoETfDxx5wKc51oOntb","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"TMUWd70zHojsjJxzJrQcEwS3nbe","block_type":4,"heading2":{"elements":[{"text_run":{"content":"静态内部类&非静态内部类","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Ylkkd0skNobaKAxaz9ocBUUOn9b","block_type":5,"heading3":{"elements":[{"text_run":{"content":"区别：","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"R70Ud2FieoOewCxHdwvcRLEgnvh","block_type":13,"ordered":{"elements":[{"text_run":{"content":"非静态内部类依赖于外部类的实例-只能通过外部类实例创建，而静态内部类不依赖于外部类的实例。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"1"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"ZNUDdAwFZoUZ37xgyu9cNdY1nGd","block_type":24,"children":["Y7eZdO0fZo2WunxxqEUcEt06nLe","G4s5d1gV9o0KgrxDDQnccYPYnab"],"grid":{"column_size":2},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Y7eZdO0fZo2WunxxqEUcEt06nLe","block_type":25,"children":["KyDedfM5Eo0JdsxfYvHc5sbMnFf"],"grid_column":{"width_ratio":42},"parent_id":"ZNUDdAwFZoUZ37xgyu9cNdY1nGd"},{"block_id":"KyDedfM5Eo0JdsxfYvHc5sbMnFf","block_type":27,"image":{"align":2,"height":45,"scale":1.6666666666666667,"token":"FIrYbr3a2oaIVLxxUdYcFWHsnyf","width":438},"parent_id":"Y7eZdO0fZo2WunxxqEUcEt06nLe"},{"block_id":"G4s5d1gV9o0KgrxDDQnccYPYnab","block_type":25,"children":["RW4ydghCtophuBxaDaMcngvWnLg"],"grid_column":{"width_ratio":57},"parent_id":"ZNUDdAwFZoUZ37xgyu9cNdY1nGd"},{"block_id":"RW4ydghCtophuBxaDaMcngvWnLg","block_type":27,"image":{"align":2,"height":39,"scale":1.3984674329501916,"token":"AWxIbQIUOohexUx5Pgec50gbnVe","width":522},"parent_id":"G4s5d1gV9o0KgrxDDQnccYPYnab"},{"block_id":"W6IcdJrqyoMvxbxQJFocYoOmnWf","block_type":13,"ordered":{"elements":[{"text_run":{"content":"非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"AJYud2s69oA2o3xffKcciLdwnMd","block_type":13,"children":["RugGd4bDVoiKbcx2HQsckCRxnXe"],"ordered":{"elements":[{"text_run":{"content":"非静态内部类不能定义静态成员，而静态内部类可以定义静态成员。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"RugGd4bDVoiKbcx2HQsckCRxnXe","block_type":12,"bullet":{"elements":[{"text_run":{"content":"非静态内部类被认为是外部类的","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"成员对象","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，在类加载的时候，静态属性和代码块会先加载，那么按照这个逻辑，非静态内部类里面的静态属性也要优先于这个内部类加载，但这个时候这个内部类都还没有初始化，这就出现矛盾了。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"AJYud2s69oA2o3xffKcciLdwnMd"},{"block_id":"BphXdPNETos2HAx1S0ycC8OXnhc","block_type":5,"heading3":{"elements":[{"text_run":{"content":"非静态内部类可以直接访问外部方法","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"UigRdNz0DoRIg5xjstRcUCDdnie","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"编译器在生成字节码时会为非静态内部类维护一个指向外部类","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"实例","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"的引用。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"KL1odGJJWoIIz4xRiYCcGihCnOg","block_type":4,"heading2":{"elements":[{"text_run":{"content":"new子类对象的加载顺序","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"K4i8dXn7QoYBPjxo6BkcRByAndh","block_type":13,"ordered":{"elements":[{"text_run":{"content":"父类静态成员变量、静态代码块","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"1"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"WrJzdHppEoKvH3xt8MIcMBZanYb","block_type":13,"ordered":{"elements":[{"text_run":{"content":"子类静态成员变量、静态代码块","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"MpX6deLuDo7l2jxfV6Ac3ogJnqf","block_type":13,"ordered":{"elements":[{"text_run":{"content":"父类构造方法","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"RtWkdaOvnoqxuMxa36ccPGMunQc","block_type":13,"ordered":{"elements":[{"text_run":{"content":"子类构造方法","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"J4s1dg1CdoAZLdxA9cKc68vAnHb","block_type":4,"heading2":{"elements":[{"text_run":{"content":"深拷贝和浅拷贝","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Ja36diP9JoVoT4xMJ8Kc5UFqnGd","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"IivrdnnEXonq3GxELNzc3uGQn8f","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。实现方法有：","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"AL1WdjLEIo5QYUx2FBFcrUlxn1d","block_type":13,"ordered":{"elements":[{"text_run":{"content":"实现 Cloneable 接口并重写 clone() 方法，手动克隆成员对象。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"1"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"UMeDdFOVioAMrHxSH6AcNi8uncc","block_type":13,"ordered":{"elements":[{"text_run":{"content":"使用序列化和反序列化：通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 Serializable 接口。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"NmBZdPVecoZ6GRxIWVjcf1s1nnj","block_type":13,"ordered":{"elements":[{"text_run":{"content":"手动递归复制：针对特定对象结构，手动递归复制对象及其引用类型字段。适用于对象结构复杂度不高的情况。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"S4O7dV6ZRo6Ihix4ti5cSqvonKd","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"Java中方法参数传递方式是按值传递。如果参数是基本类型，传递的是基本类型的字面量值的拷贝。如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"UTvQd8pzeopBSExFgC7cyEDCnlh","block_type":27,"image":{"align":2,"height":514,"scale":1,"token":"Wdh4bk2dKo0Eu4xntd4co56QnWh","width":1159},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"G0LtdCaFhotz72xUvqrcUTiBnAn","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"HUMvdRoQEo6XhDxyBHucrS2Rncd","block_type":3,"heading1":{"elements":[{"text_run":{"content":"泛型","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"YSbtdP21boDQ1wxWl2TcZieDnAe","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"泛型是 Java 编程语言中的一个重要特性(语法糖)，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"不能使用泛型创建数组。","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"QAM0dg73ZofcLPxsfNZcHHPwnYe","block_type":14,"code":{"elements":[{"text_run":{"content":"// 泛型类\nclass Box<T> {\n    private T value;\n    public void set(T value) { this.value = value; }\n    public T get() { return value; }\n}\n// 泛型接口/方法\npublic <T> T copy(T obj) {\n    return obj;\n","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"}","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"language":63,"wrap":true}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"T8jldF80GocD5zx3IqUcZsHlnuf","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"一个泛型队列，狗可以站进来，猫也可以站进来，但最好不要既站猫，又站狗。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"YnDHd8FXwonUskx7ey8cb2sCnLc","block_type":2,"children":["GRcQdltoKoSR47xKTP8cn1aInEc","QMBXdWyEIoMtA8x4qENcqd7xnAf","JqS3d72cloQZnlxJr8Tc6Q9Pnwb"],"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"泛型擦除：Java 的泛型 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"在编译期检查类型安全","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，而 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"运行时 JVM 不保留泛型类型信息","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，编译后会 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"擦除类型参数","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，这种机制称为 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"泛型擦除（Type Erasure）","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"GRcQdltoKoSR47xKTP8cn1aInEc","block_type":12,"bullet":{"elements":[{"text_run":{"content":"泛型边界（Bound）指 泛型类型参数允许的类型范围，主要用于约束泛型类型，保证类型安全。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"children":["Ytgjdfjjlo9RFvx7UwocTj1anLh","CQundEunSoYg6sxscXgcFtX8nAb","P22JdLqFlocPutxA3NhcTBqbndg"],"parent_id":"YnDHd8FXwonUskx7ey8cb2sCnLc"},{"block_id":"Ytgjdfjjlo9RFvx7UwocTj1anLh","block_type":12,"bullet":{"elements":[{"text_run":{"content":"上界：","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"T extends SomeClass","text_element_style":{"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" → ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"T 及其子类","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"都可以，默认Object，编译后，","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"T","text_element_style":{"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 被 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"擦除为上界类型。","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"GRcQdltoKoSR47xKTP8cn1aInEc"},{"block_id":"CQundEunSoYg6sxscXgcFtX8nAb","block_type":12,"bullet":{"elements":[{"text_run":{"content":"下界：下界一般在 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"通配符中使用","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，例如 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"? super T","text_element_style":{"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 。表示泛型参数可以是 T 本身或 T 的父类","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"GRcQdltoKoSR47xKTP8cn1aInEc"},{"block_id":"P22JdLqFlocPutxA3NhcTBqbndg","block_type":2,"parent_id":"GRcQdltoKoSR47xKTP8cn1aInEc","text":{"elements":[{"text_run":{"content":"如果不写上界，默认是 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"Object","text_element_style":{"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"QMBXdWyEIoMtA8x4qENcqd7xnAf","block_type":12,"bullet":{"elements":[{"text_run":{"content":"运行时无法判断泛型类型：","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"YnDHd8FXwonUskx7ey8cb2sCnLc"},{"block_id":"JqS3d72cloQZnlxJr8Tc6Q9Pnwb","block_type":14,"code":{"elements":[{"text_run":{"content":"if(obj instanceof Box<String>) {} // ❌ 编译错误","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"language":29,"wrap":true}},"parent_id":"YnDHd8FXwonUskx7ey8cb2sCnLc"},{"block_id":"ZAODdb0FYo1WHkxgcD4cXtCWnqf","block_type":3,"heading1":{"elements":[{"text_run":{"content":"函数式接口","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"IrWhd0R4io23RqxnpQhcaUnunMc","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"函数式接口是 只包含一个抽象方法的接口，可以隐式转换为 Lambda 表达式。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"FXOJdYMrGoOAWmxHvnlchJ71ndU","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"Lambda 表达式本质上是函数式接口的实例。编译器会根据函数式接口推导类型。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"MytpdsJ20oKysIxO7KeczMncnMe","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"定义方式：","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"FraNdqcZ1oj0rYxQTTcca2e8nug","block_type":13,"ordered":{"elements":[{"text_run":{"content":" 定义接口并保证 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"只有一个抽象方法","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"1"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"CSY4dhNnro72jKxheVJciIaenj7","block_type":13,"ordered":{"elements":[{"text_run":{"content":"推荐加上 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"@FunctionalInterface","text_element_style":{"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 注解，编译器会检查接口是否满足函数式接口要求。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"VqThdUnrRobit7xn20acPUWLnrb","block_type":3,"heading1":{"elements":[{"text_run":{"content":"对象","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"CLiXdJ8yAopMWpxHr4UczDaKnLf","block_type":4,"heading2":{"elements":[{"text_run":{"content":"创建对象的方式","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"W6DydckbXoKqskx8SOEcvwlRnOb","block_type":13,"ordered":{"elements":[{"text_run":{"content":"使用new关键字","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"1"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Oue9dgJaKoOMbrxpCl8cncUMnNp","block_type":13,"ordered":{"elements":[{"text_run":{"content":"使用Class类的newInstance()方法","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"CSNDdrkqjoVakKxyW0pcltD4nJb","block_type":27,"image":{"align":2,"height":82,"scale":1,"token":"S4Scbr11IoPyiCxxJVGcSWQ8nEc","width":757},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"GytAdjXCQoh1rwxFKpscCRGqnQb","block_type":13,"ordered":{"elements":[{"text_run":{"content":"如果类实现了Cloneable接口，可以使用clone()方法复制对象。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"MNR2dpWX1o5oOBxR8Vzc4XY1nOb","block_type":13,"ordered":{"elements":[{"text_run":{"content":"使用反序列化","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"LGTtdeqI1o4WnwxPcSpc3W64nFf","block_type":4,"heading2":{"elements":[{"text_run":{"content":"继承规则","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"XdZqdTJOUouNngxBr6aczh8VnV5","block_type":12,"bullet":{"elements":[{"text_run":{"content":"要成功重写，子类方法必须与父类被重写方法拥有完全相同的方法签名​（方法名、参数列表）和返回类型​（或是其子类，JDK 5+ 支持协变返回类型-允许返回类型是父类方法返回类型的","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"子类","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"）。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"VlKndadxNoauFSxVBkgcQGAgnge","block_type":12,"bullet":{"elements":[{"text_run":{"content":"子类重写方法的访问权限不能比父类方法更严格​（例如，父类方法是 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"protected","text_element_style":{"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，子类可以是 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"protected","text_element_style":{"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"或 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"public","text_element_style":{"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，但不能是 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"private","text_element_style":{"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"或 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"default","text_element_style":{"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"）","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"children":["Io44dZBIfoFSHaxnMUCcSnnzn7g"],"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Io44dZBIfoFSHaxnMUCcSnnzn7g","block_type":12,"bullet":{"elements":[{"text_run":{"content":"访问权限规则确保 “父类允许的访问，子类不能禁止”；","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"VlKndadxNoauFSxVBkgcQGAgnge"},{"block_id":"EZCFdgKsloP6AVxJxgncODIinFg","block_type":12,"bullet":{"elements":[{"text_run":{"content":"子类重写方法不能抛出比父类方法更宽泛的检查异常（即不能抛出父类方法抛出异常的父类）","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"children":["ViGAd4lxVo0xt7xqK1ZcrKQan5b"],"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"ViGAd4lxVo0xt7xqK1ZcrKQan5b","block_type":12,"bullet":{"elements":[{"text_run":{"content":"父类声明的风险范围，子类不能扩大","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"EZCFdgKsloP6AVxJxgncODIinFg"},{"block_id":"CfhKdJQ1yo0ZdaxRH48cHK99nmc","block_type":12,"bullet":{"elements":[{"text_run":{"content":"被 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"final","text_element_style":{"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"、","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"static","text_element_style":{"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"或 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"private","text_element_style":{"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"修饰的父类方法不能被重写","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"CiFBdEvtsoU26Mxv9BBcYExKnib","block_type":3,"heading1":{"elements":[{"text_run":{"content":"反射","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"E64Td5Qhrot4SWxOduxcIH9GnCd","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"BWbSdY8q6oqNjDx4lpvcgkOWn7g","block_type":27,"image":{"align":2,"height":321,"scale":1,"token":"K1zBbpKohojMX5xTs4Tc3kxBn5e","width":1118},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"YhOZd2C2qofIZixwuFDceupznMb","block_type":4,"heading2":{"elements":[{"text_run":{"content":"应用场景","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"EHe7dgbbcoPZTMxQY2JcTWFpnZr","block_type":13,"ordered":{"elements":[{"text_run":{"content":"加载数据库驱动","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"1"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"SXhhdrv6eoOqOqx5T0fcgdLYntb","block_type":13,"ordered":{"elements":[{"text_run":{"content":"加载配置文件","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"M9xFd7KtUoG5v9xvoS4cP1WAnxd","block_type":13,"ordered":{"elements":[{"text_run":{"content":"获取类的class实例、创建实例对象、调用方法","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Nsg9dnf78oomXRxq8QVcj7J2nrb","block_type":3,"heading1":{"elements":[{"text_run":{"content":"AOP","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Gux4dDqPboGIdWxL13hc2ZxtnZc","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，核心思想是","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"将与业务逻辑无关但被多个模块共同调用的通用功能（如日志、事务、权限校验等）抽离出来，形成独立的 “切面”","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，通过动态织入的方式在不修改原有业务代码的前提下，对业务方法进行增强。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"QXludKHaWoRbioxUXLccs2ELnMc","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"AOP 解决了传统 OOP 中 “横切关注点”（跨多个类的重复代码）的代码冗余问题，提高了代码的复用性和可维护性。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"R0xLdZrMBotGCMxYYHScpAAknGb","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"Spring AOP 基于注解的开发模式中，","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"@Aspect","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 定义切面，","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"@Pointcut","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 定义目标范围，","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"@Before","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"/","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"@After","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"/","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"@Around","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 等注解定义增强逻辑。这些注解简化了 AOP 的使用","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"MZWgdqK0fo7hawxkQxFclHHnnsb","block_type":5,"heading3":{"elements":[{"text_run":{"content":"AOP 核心概念","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Jm3gdyJGsomZi1xIWDScr8YInYr","block_type":12,"bullet":{"elements":[{"text_run":{"content":"切面（Aspect）","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"：封装横切关注点的类（如日志切面、事务切面），包含通知和切入点。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"JbqOdAka1oQ9odxcdfbcLmtEnDe","block_type":12,"bullet":{"elements":[{"text_run":{"content":"通知（Advice）","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"：切面的具体执行逻辑（如日志打印代码），按执行时机分为 5 种类型。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"DUqZdvg2Qokf4kxhBXjcUiRWn2b","block_type":12,"bullet":{"elements":[{"text_run":{"content":"切入点（Pointcut）","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"：定义通知作用的 “目标方法范围”（如指定哪些类的哪些方法需要被增强）。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"TWxld3qPvorDyTxbspScddBKn6b","block_type":12,"bullet":{"elements":[{"text_run":{"content":"连接点（JoinPoint）","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"：程序执行过程中可被增强的点（如方法调用、异常抛出等，切入点是连接点的子集）。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"I8mbdO3vZoIM7QxGcW2chTrhnwc","block_type":12,"bullet":{"elements":[{"text_run":{"content":"织入（Weaving）","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"：将切面代码插入到目标方法的过程（Spring AOP 默认在运行时通过动态代理织入）。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Z7C6df4JqoNoRPxfuzhczsFcnXd","block_type":3,"heading1":{"elements":[{"text_run":{"content":"注解","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Hk5gdPuXoo5YRMxdNqWcH35Cnxd","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"注解本质是一个继承了Annotation的特殊接口， Java 提供的一种 元数据机制，用于向类、方法、字段、参数等元素 提供额外信息。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"RUHRdOFh6oEypBxdTB5cjbTXnRh","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"编译器会为注解生成 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"动态代理对象","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"（","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"Proxy","text_element_style":{"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"）实现接口，运行期调用 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"getAnnotation()","text_element_style":{"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，返回 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"动态代理对象","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，内部持有注解属性值。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"SOPJd729YowkMLxJsvVcjBeAnBd","block_type":3,"heading1":{"elements":[{"text_run":{"content":"异常","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"OHjoduZboobeW1x199PceUq9nyf","block_type":24,"children":["HRWkdzoEmoNj8VxXM1Bc1Yy2nFc","UpkcdGKpsoHlSkxBuCScOS7jnhg"],"grid":{"column_size":2},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"HRWkdzoEmoNj8VxXM1Bc1Yy2nFc","block_type":25,"children":["MKeHdRUlzoelC2x6KVnc1q19nNh"],"grid_column":{"width_ratio":57},"parent_id":"OHjoduZboobeW1x199PceUq9nyf"},{"block_id":"MKeHdRUlzoelC2x6KVnc1q19nNh","block_type":27,"image":{"align":2,"height":114,"scale":1.8295739348370927,"token":"XFCIbnmEkozFLJxQMHDc4MJdnIH","width":399},"parent_id":"HRWkdzoEmoNj8VxXM1Bc1Yy2nFc"},{"block_id":"UpkcdGKpsoHlSkxBuCScOS7jnhg","block_type":25,"children":["E7EHd5aNnokrn2xWXLecG4uankg"],"grid_column":{"width_ratio":42},"parent_id":"OHjoduZboobeW1x199PceUq9nyf"},{"block_id":"E7EHd5aNnokrn2xWXLecG4uankg","block_type":27,"image":{"align":2,"height":661,"scale":0.8760683760683761,"token":"QNWfbjxX8oIt3mxMyQJc2hrxnQf","width":936},"parent_id":"UpkcdGKpsoHlSkxBuCScOS7jnhg"},{"block_id":"Rf8qdKfy9oL5qwxlOg3c4AjcnVg","block_type":4,"heading2":{"elements":[{"text_run":{"content":"Error","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"GxDCd9OnhowNxrx2IRccO3ann9D","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"表示运行时环境的错误。错误是程序无法处理的严重问题，如系统崩溃、虚拟机错误、动态链接失败等。通常，程序不应该尝试捕获这类错误。例如，OutOfMemoryError、StackOverflowError等。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"WUDpdZoOfo9BTgx6UO4ckRgPnDg","block_type":4,"heading2":{"elements":[{"text_run":{"content":"Exception","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"SGfWdwJDEotkVMxKHLvcUmgSnqf","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"表示程序本身可以处理的异常条件。异常分为两大类：","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"KwYmdrjMEoKsRyxfl1NcOXdOnKd","block_type":13,"ordered":{"elements":[{"text_run":{"content":"非运行时异常-检查型异常：这类异常在编译时期就必须被捕获或者声明抛出。它们通常是外部错误，如文件不存在（FileNotFoundException）、类未找到（ClassNotFoundException）等。非运行时异常强制程序员处理这些可能出现的问题，增强了程序的健壮性。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"1"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"GxMgdSgXrovEz2xww1fcNJnpn6f","block_type":13,"ordered":{"elements":[{"text_run":{"content":"运行时异常-非检查异常：这类异常包括运行时异常（RuntimeException）和错误（Error）。运行时异常由程序错误导致，如空指针访问（NullPointerException）、数组越界（ArrayIndexOutOfBoundsException）等。运行时异常是不需要在编译时强制捕获或声明的。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Ak37ddzz1op0jwxWas8cSEJWnCb","block_type":4,"heading2":{"elements":[{"text_run":{"content":"处理","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"QIBBdZGfNoQfazxCQy6crx0lnEp","block_type":12,"bullet":{"elements":[{"text_run":{"content":"如果异常是未检查异常(Unchecked)或者在方法内部被捕获和处理了，那么就不需要使用throws。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Awpbdcid7oFmOlxcjcbckJJin8b","block_type":12,"bullet":{"elements":[{"text_run":{"content":"无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"children":["GULed61XQo2AuexEcodcUV0MnKW","IlQ4d30pEoP0qtxErnZcwQQZntv","NMqXdvgPvoaeCOxLdhscmrGin4f","NmWUdUXQ1owCHtxCpL4cra6Jnch"],"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"GULed61XQo2AuexEcodcUV0MnKW","block_type":12,"bullet":{"elements":[{"text_run":{"content":"当 try 代码块和 catch 代码块中有 return 语句时，finally 仍然会被执行。执行 try 代码块或 catch 代码块中的 return 语句之前，都会先执行 finally 语句。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"Awpbdcid7oFmOlxcjcbckJJin8b"},{"block_id":"IlQ4d30pEoP0qtxErnZcwQQZntv","block_type":12,"bullet":{"elements":[{"text_run":{"content":"无论在 finally 代码块中是否修改返回值，返回值都不会改变，仍然是执行 finally 代码块之前的值。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"Awpbdcid7oFmOlxcjcbckJJin8b"},{"block_id":"NMqXdvgPvoaeCOxLdhscmrGin4f","block_type":12,"bullet":{"elements":[{"text_run":{"content":"finally 代码块中的 return 语句一定会执行。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"Awpbdcid7oFmOlxcjcbckJJin8b"},{"block_id":"NmWUdUXQ1owCHtxCpL4cra6Jnch","block_type":12,"bullet":{"elements":[{"text_run":{"content":"原理：","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"children":["Va8sdGqNlouCsnxqhJzc6gijnYf","BYyqdWviToTkN4xyynpc1scbn7S","VjXKdWvoNoBRoHx3oo4cDMJznFg","QLPfd5ot9ouPlKxGsrJcbrQRnGc","NWs7dqVKuojEY5xpTurc7ttinyh"],"parent_id":"Awpbdcid7oFmOlxcjcbckJJin8b"},{"block_id":"Va8sdGqNlouCsnxqhJzc6gijnYf","block_type":2,"parent_id":"NmWUdUXQ1owCHtxCpL4cra6Jnch","text":{"elements":[{"text_run":{"content":"当 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"try","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 或 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"catch","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 块中存在 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"return","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 时，JVM 的执行步骤是：","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"BYyqdWviToTkN4xyynpc1scbn7S","block_type":13,"ordered":{"elements":[{"text_run":{"content":"计算 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"return","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 后的表达式值（如 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"return a + b;","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 会先计算 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"a + b","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 的结果），并将结果暂存到一个临时变量中；","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"1"}},"parent_id":"NmWUdUXQ1owCHtxCpL4cra6Jnch"},{"block_id":"VjXKdWvoNoBRoHx3oo4cDMJznFg","block_type":13,"ordered":{"elements":[{"text_run":{"content":"暂停 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"return","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 流程，跳转到 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"finally","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 块执行所有代码；","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"NmWUdUXQ1owCHtxCpL4cra6Jnch"},{"block_id":"QLPfd5ot9ouPlKxGsrJcbrQRnGc","block_type":13,"ordered":{"elements":[{"text_run":{"content":"finally","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 块执行完毕后，再从临时变量中取出之前暂存的结果，完成 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"return","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 操作。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"NmWUdUXQ1owCHtxCpL4cra6Jnch"},{"block_id":"NWs7dqVKuojEY5xpTurc7ttinyh","block_type":13,"ordered":{"elements":[{"text_run":{"content":"进入 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"finally","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 块后，若执行到 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"return","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，JVM 会直接使用该 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"return","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 的值作为最终结果，","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"丢弃之前暂存的返回值","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，且不会再回到 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"try","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"/","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"catch","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 块的 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"return","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"NmWUdUXQ1owCHtxCpL4cra6Jnch"},{"block_id":"SZfdd6qfvoDkYnxZIUZcuDHonfe","block_type":12,"bullet":{"elements":[{"text_run":{"content":"finally不执行情况：","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"children":["MmFZdKzThosjhnx7xGGc1LEPnTb","W2CBdUbNFo06CyxjeA2coWs4n9b","JBUQdTic7o0AqUxUGQ2c1wdHnFd"],"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"MmFZdKzThosjhnx7xGGc1LEPnTb","block_type":12,"bullet":{"elements":[{"text_run":{"content":"JVM 崩溃（","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"OutOfMemoryError","text_element_style":{"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"、","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"StackOverflowError","text_element_style":{"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"）","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"SZfdd6qfvoDkYnxZIUZcuDHonfe"},{"block_id":"W2CBdUbNFo06CyxjeA2coWs4n9b","block_type":12,"bullet":{"elements":[{"text_run":{"content":"调用 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"System.exit()","text_element_style":{"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"SZfdd6qfvoDkYnxZIUZcuDHonfe"},{"block_id":"JBUQdTic7o0AqUxUGQ2c1wdHnFd","block_type":12,"bullet":{"elements":[{"text_run":{"content":"线程被杀掉","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"SZfdd6qfvoDkYnxZIUZcuDHonfe"},{"block_id":"HC0XdjsYEojAdfxyPOYc8FTZnqf","block_type":4,"heading2":{"elements":[{"text_run":{"content":"try with resources","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"LIepdNispo7lstxwmqHc8Z9On4f","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"把要手动关闭的资源放在try()括号里","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"K6IEdMOI4oRI6TxAEFmcGew8nGc","block_type":14,"code":{"elements":[{"text_run":{"content":"try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File(\"test.txt\")));\n     BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File(\"out.txt\")))) {\n    int b;\n    while ((b = bin.read()) != -1) {\n        bout.write(b);\n    }\n}\ncatch (IOException e) {\n    e.printStackTrace();\n","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"}","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"language":1,"wrap":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"FqKgd4XCOogOLOxiRBYcXm6gnMd","block_type":4,"heading2":{"elements":[{"text_run":{"content":"线程池中的异常","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"J0y7dSZo9oOIDOxjrXQcOZlXnra","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"1、execute方法,可以看异常输出在控制台，而submit在控制台没有直接输出，必须调用Future.get()方法时，可以捕获到异常。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"MZ0dd85PEoOhvgxiCUzcVqLJnhf","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"2、一个线程出现异常不会影响线程池里面其他线程的正常执行。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"VGoidQ7DAoCklbxdCoVcdh0KnXd","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"3、线程不是被回收而是线程池把这个线程移除掉，同时创建一个新的线程放到线程池中。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"MVSRdoUQCoT1O4xDyR9cuYtmnme","block_type":3,"heading1":{"elements":[{"text_run":{"content":"Objects","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"OsOFdOto2oKGPuxP5ERcbD76nSe","block_type":4,"heading2":{"elements":[{"text_run":{"content":"==&equals","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"ST8LdERqfoH04hxP4vbclEdWnhT","block_type":12,"bullet":{"elements":[{"text_run":{"content":"== 运算符：本质是比较「内存地址」。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"children":["HkfFdVa5NoOZlwxxqKzcD37xn2d","U3pOdmVoromVHixtTcEcYiLinWh"],"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"HkfFdVa5NoOZlwxxqKzcD37xn2d","block_type":12,"bullet":{"elements":[{"text_run":{"content":"对基本类型（如 int、char）：比较的是「值」（因基本类型直接存储值，无内存地址概念）。成员变量和局部变量没有区别。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"ST8LdERqfoH04hxP4vbclEdWnhT"},{"block_id":"U3pOdmVoromVHixtTcEcYiLinWh","block_type":12,"bullet":{"elements":[{"text_run":{"content":"对引用类型（如 String、自定义类对象）：比较的是「对象的内存地址」，判断是否为同一个对象。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"ST8LdERqfoH04hxP4vbclEdWnhT"},{"block_id":"F8RRdHQHBo8pYFxbOa7ccti4n9g","block_type":12,"bullet":{"elements":[{"text_run":{"content":"equals() 方法：本质是「对象的内容比较」，但需注意默认行为。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"children":["YjQbdk7v2odA6BxAnaVczKd3nxp","CEjxdQ6EnoBsXyxJ6MmcraUWnke","SaA8dH34PoqR9Nxqh5ycqySWnpd"],"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"YjQbdk7v2odA6BxAnaVczKd3nxp","block_type":12,"bullet":{"elements":[{"text_run":{"content":"未重写时（默认继承自 Object 类）：等同于 ==，比较「内存地址」。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"F8RRdHQHBo8pYFxbOa7ccti4n9g"},{"block_id":"CEjxdQ6EnoBsXyxJ6MmcraUWnke","block_type":12,"bullet":{"elements":[{"text_run":{"content":"重写后（如 String、Integer 等常用类）：按业务逻辑比较「对象内容」（如 String 的 equals() 比较字符序列是否一致）。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"F8RRdHQHBo8pYFxbOa7ccti4n9g"},{"block_id":"SaA8dH34PoqR9Nxqh5ycqySWnpd","block_type":12,"bullet":{"elements":[{"text_run":{"content":"当两个 key 的哈希值hashCode()相同（哈希冲突）时，HashMap 会调用 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"equals()","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 比较两者的实际内容，判断是否为同一个 key。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"F8RRdHQHBo8pYFxbOa7ccti4n9g"},{"block_id":"WjAnd9UZnoTG0LxPCOfcwAeDnwf","block_type":4,"heading2":{"elements":[{"text_run":{"content":"String","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"STq7dfO5uodsYPxBq7Nc4F8inQe","block_type":2,"children":["XBRedwdBho72Frxj7Fccy9d8nKg","UMJrd8q6WoLJFOxgV0cc26WinZf"],"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"字符串对象通过“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 StringBuilder 以复用，会导致创建过多的 StringBuilder 对象","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"XBRedwdBho72Frxj7Fccy9d8nKg","block_type":12,"bullet":{"elements":[{"text_run":{"content":"String底层：private final char[] value。value不可变，因此String提供的api需要重新创建一个字符数组。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"STq7dfO5uodsYPxBq7Nc4F8inQe"},{"block_id":"UMJrd8q6WoLJFOxgV0cc26WinZf","block_type":12,"bullet":{"elements":[{"text_run":{"content":"concat/+：","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"children":["OLEYd18Ruo0bVyxiIJpck15xnNb","YVNrdIYRXohju3xHriVc42ewnVA"],"parent_id":"STq7dfO5uodsYPxBq7Nc4F8inQe"},{"block_id":"OLEYd18Ruo0bVyxiIJpck15xnNb","block_type":12,"bullet":{"elements":[{"text_run":{"content":"concat：计算拼接后的总长度（原长度 + str 长度）；再创建","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"新的字符数组","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，先复制原字符串的字符，再复制 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"str","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 的字符","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"UMJrd8q6WoLJFOxgV0cc26WinZf"},{"block_id":"YVNrdIYRXohju3xHriVc42ewnVA","block_type":12,"bullet":{"elements":[{"text_run":{"content":"+：StringBuilder","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"UMJrd8q6WoLJFOxgV0cc26WinZf"},{"block_id":"XGvydkqqooB5dZx1hdKc8UVRnlw","block_type":3,"heading1":{"elements":[{"text_run":{"content":"序列化","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"W89ydvP9loMzkexZuRrcJPXmnvd","block_type":4,"heading2":{"elements":[{"text_run":{"content":"怎么把一个对象从一个jvm转移到另一个jvm?","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"JTUIdlAtool5ZLxFKP4c755Nnnf","block_type":13,"ordered":{"elements":[{"text_run":{"content":"使用序列化和反序列化：将对象序列化为字节流，并将其发送到另一个 JVM，然后在另一个 JVM 中反序列化字节流恢复对象。这可以通过 Java 的 ObjectOutputStream 和 ObjectInputStream 来实现。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"1"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"EctdddhOFo7ZKOxBVP4cffLenii","block_type":13,"ordered":{"elements":[{"text_run":{"content":"使用消息传递机制：利用消息传递机制，比如使用消息队列（如 RabbitMQ、Kafka）或者通过网络套接字进行通信，将对象从一个 JVM 发送到另一个。这需要自定义协议来序列化对象并在另一个 JVM 中反序列化。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"YnuNdiGU4o2U6sxIgaQcLwUznOe","block_type":13,"ordered":{"elements":[{"text_run":{"content":"使用远程方法调用（RPC）：可以使用远程方法调用框架，如  gRPC，来实现对象在不同 JVM 之间的传输。远程方法调用可以让你在分布式系统中调用远程 JVM 上的对象的方法。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"WaXudSJ0koy1vMxmxxkcmCaln0r","block_type":13,"ordered":{"elements":[{"text_run":{"content":"使用共享数据库或缓存：将对象存储在共享数据库（如 MySQL、PostgreSQL）或共享缓存（如 Redis）中，让不同的 JVM 可以访问这些共享数据。这种方法适用于需要共享数据但不需要直接传输对象的场景。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"WzVrdGtIzoPLLwxKUnmcYyJdnAe","block_type":4,"heading2":{"elements":[{"text_run":{"content":"将对象转为二进制字节流具体怎么实现","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"XGBNdmfvlo3kumxmWEqcYOtynsg","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"序列化机制是通过序列化协议来进行处理的，和 class 文件类似，它其实是定义了序列化后的字节流格式，然后对此格式进行操作，生成符合格式的字节流或者将字节流解析成对象。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"A7cwdGlZ2oIWuuxHSWscJok3nkg","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"在Java中通过序列化对象流来完成序列化和反序列化：","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"PLI0d8MpVoAqK2xNaAXc0bMMn1G","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"ObjectOutputStream：通过writeObject(）方法做序列化操作。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"F7R0dwA1mofA6qxevTscLAtgnKE","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"ObjectInputStream：通过readObject()方法做反序列化操作。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"ERCfdxA2zo9dfRxYQXycQZKVnNd","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常！","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"FOTTdUqOWoAXWgxc2nMcH8tgn84","block_type":5,"heading3":{"elements":[{"text_run":{"content":"序列化","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"TYIbdGwSQow2Chx9y9Sc5LYlnsh","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"让类实现Serializable接口，对于不想进行序列化的变量，使用 transient 关键字修饰：","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"UI9MdsFmZosPE4xxU5ncVUvZnac","block_type":27,"image":{"align":2,"height":171,"scale":1,"token":"RgOVblQ9lodlznxwuZ9c5IAgnAq","width":525},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"BgXWdki6foXAX0x5xpIcLnxZnlb","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"创建输出流并写入对象：","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"KwVsdSVpGowsQSxjZQUcnsMWnBc","block_type":27,"image":{"align":2,"height":451,"scale":1,"token":"ZOQrb3jaooght3x6GspcWKF8nKc","width":774},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"G88idE4sVowoshxTriockgHjnCc","block_type":5,"heading3":{"elements":[{"text_run":{"content":"反序列化","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"MAnRdLkBdo2ufrx00eUcOdMKntb","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"创建输入流并读取对象：","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"R7qQdXCJcoxJRjxxK4xcISKlnZb","block_type":27,"image":{"align":2,"height":463,"scale":1,"token":"Su14bNjPpoVvXvxEF4EcSOppnuc","width":750},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"L77QdxVP6o0gWcx7tH1c8YFGn1d","block_type":4,"heading2":{"elements":[{"text_run":{"content":"serialVersionUID","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"E4ZudwfU3oMRmqx4sPvconZFnXg","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"序列化号属于版本控制的作用。反序列化时，会检查反序列化对象的 serialVersionUID 是否和当前类的 serialVersionUID 一致。如果 serialVersionUID 不一致则会抛出InvalidClassException 异常。强烈推荐每个序列化类都手动指定其serialVersionUID，如果不手动指定，那么编译器会动态生成默认的 serialVersionUID。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"RFAddEIp9ohS4YxtilNctrconU1","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"特例：虽然serialVersionUID被static修饰，serialVersionUID 的序列化做了特殊处理。当一个对象被序列化时，serialVersionUID 会被写入到序列化的二进制流中；在反序列化时，也会解析它并做一致性判断，以此来验证序列化对象的版本一致性。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"SUxmd51sZoEilbxBYmuciIVTn3e","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"也即serialVersionUID 只是用来被 JVM 识别，实际并没有被序列化。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"UBBudTLg5oybyCxh2ANcKe8wnth","block_type":3,"heading1":{"elements":[{"text_run":{"content":"设计模式","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Q23Od6lXVoIGGSxgI5IczFr4nYK","block_type":4,"heading2":{"elements":[{"text_run":{"content":"单例模式-双重锁校验","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"KvnFdRmpjooy1SxEZmycF8Lhnnp","block_type":27,"image":{"align":2,"height":649,"scale":1,"token":"SDXmbVNayoF6mxxmJRKcS7nXnNb","width":1104},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"DqNrdC6mXoe8MIx80HmcBWbMnDd","block_type":12,"bullet":{"elements":[{"text_run":{"content":"第一次校验，也就是第一个判断if(singleton == null)，意义是由于单例模式只需创建一个实例，所以当第一次创建实例成功之后，再次调用Singleton.getInstance()就没有必要进入同步锁代码块，直接返回之前创建的实列即可。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"DTbGd1X9Xo75E7xis1acSy9KnWc","block_type":12,"bullet":{"elements":[{"text_run":{"content":"第二次校验，也就是第二次判断if(singleton == null)：假如有两个线程，此时singleton由于为空，所以它们可以同时进入第一个if，A线程先拿到了锁，那么B线程只能等待A线程执行完把锁释放掉才能获取，A线程执行完此时已经创建了一个实例。如果没有第二个if判空，等B线程拿到锁资源后就会创建出第二个实例，第二次判空是必要的","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"YBMQdLqp7ofvTnxrZdicyN35nge","block_type":12,"bullet":{"elements":[{"text_run":{"content":"volatile：说人话就是同一个线程内执行赋值操作顺序可能会和我们写的代码的顺序不一样，但是在同一个线程内感觉不到这种不同的顺序。但是在多线程可以感觉到，所以需要使用volatile来避免这种指令重排序导致的错误。参考如下情况，A、B两个线程创建单例，此时A已经赋值，但是没有完成变量初始化，而B线程看到instance已经赋值就拿来使用，因为instance没有完成初始化，所以使用过程中可能产生无法预料的后果。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"EmqedKpmjoyzKSxDZZLcz2a9nDb","block_type":4,"heading2":{"elements":[{"text_run":{"content":"代理","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"AXxrdPKNOouHqoxzqUucOcmsnhd","block_type":5,"heading3":{"elements":[{"text_run":{"content":"静态代理","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"R6OzdxWWJoTA3axty7GctutOn9g","block_type":13,"ordered":{"elements":[{"text_run":{"content":"定义一个接口及其实现类；","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"1"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"FtIZdiRCooGFaExsbGQc5RLznrb","block_type":13,"ordered":{"elements":[{"text_run":{"content":"创建一个代理类同样实现这个接口","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"KYAjdSW56o8mgWxpAPHcTRTen6b","block_type":13,"ordered":{"elements":[{"text_run":{"content":"将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Jjs7dfjHTothFSxQM6qco2HknSh","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"BmTiduQoboeD48x54t6cE02xnqh","block_type":5,"heading3":{"elements":[{"text_run":{"content":"动态代理","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"OOVwdW8tQo8XKLxAcqGcUYzrnDg","block_type":6,"heading4":{"elements":[{"text_run":{"content":"JDK动态代理","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"XL7KdUVhpokW0gx0I0lc2peHnwf","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"运行时生成代理类，通过实现目标类的接口来增强方法功能","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"FlDzdNhwGoloxLx96fDcgrcZnl3","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"JDK 动态代理","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"只能增强被代理类所实现的接口中的方法","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，无法直接增强代理类自身的非接口方法（即类中独有的方法，未在接口中声明的方法）。这是由 JDK 动态代理的底层实现机制决定的。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"OeEHdb8xCou6Vwx8DMncHdSJnDg","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"JDK 动态代理的核心是通过 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"java.lang.reflect.Proxy","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 类在运行时动态生成代理类的字节码，其生成的代理类有两个关键特征：","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"UvYudv3YJoa8gExXPXAcJ0bTnUc","block_type":13,"ordered":{"elements":[{"text_run":{"content":"代理类会实现目标类所实现的所有接口","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，并重写接口中的方法（这是增强逻辑的切入点）。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"1"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"C9okdmwFNoOYQoxaFL3cRggqn1c","block_type":13,"ordered":{"elements":[{"text_run":{"content":"代理类与目标类之间没有继承关系","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"，而是通过持有目标类的引用（","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"InvocationHandler","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 中的 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"target","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 对象）来调用目标方法。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"REdadtgXwoKWk7xIPvDccMbqnmf","block_type":14,"code":{"elements":[{"text_run":{"content":"interface Service { void doSomething(); }\nclass RealService implements Service { public void doSomething(){System.out.println(\"RealService\");} }\n\nService proxy = (Service) Proxy.newProxyInstance(\n    RealService.class.getClassLoader(),\n    new Class[]{Service.class},\n    (proxyObj, method, args) -> {\n        System.out.println(\"Before\");\n        Object result = method.invoke(new RealService(), args);\n        System.out.println(\"After\");\n        return result;\n    }\n);\nproxy.doSomething();\n","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"language":29,"wrap":true}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"RFE2dKLcWoLLNvxFkrTccsMwnFf","block_type":6,"heading4":{"elements":[{"text_run":{"content":"cglib动态代理(code generation library)","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"V3modj4R7o4j2fx8Kkvc6yXEn5b","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"CGLIB（Code Generation Library）是一个基于字节码生成的代码生成库，它通过","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"继承目标类并生成子类（代理类）","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":" 的方式实现动态代理，因此可以突破 JDK 动态代理的限制 —— 不仅能增强接口方法，还能增强目标类中","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"非接口的 public/protected 方法","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"（甚至包括未实现任何接口的类的方法）。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"WuUmd7CBpoGaqyxK01RcCVMEnDd","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"CGLIB 的底层通过 ASM 字节码框架直接操作字节码，在运行时动态生成目标类的","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"子类","text_element_style":{"bold":true,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"（代理类），并在子类中重写父类的方法（被增强的方法）。代理类会持有一个 ","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"MethodInterceptor","text_element_style":{"background_color":14,"bold":false,"inline_code":true,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"（方法拦截器）对象，当调用代理对象的方法时，会先触发拦截器的逻辑，再通过反射调用目标类的原方法，从而实现增强。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"QoAOdedSeoICYmxctb1c5YS4nST","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"子类能做的事，cglib都能做。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"Le6rd16zIoyGO0xVfTkc2LxwnAf","block_type":14,"code":{"elements":[{"text_run":{"content":"class RealService { public void doSomething(){System.out.println(\"RealService\");} }\n\nEnhancer enhancer = new Enhancer();\nenhancer.setSuperclass(RealService.class);\nenhancer.setCallback((obj, method, args, proxy) -> {\n    System.out.println(\"Before\");\n    Object result = proxy.invokeSuper(obj, args);\n    System.out.println(\"After\");\n    return result;\n});\nRealService proxy = (RealService) enhancer.create();\nproxy.doSomething();\n","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"language":29,"wrap":true}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"Zt31dKT8xoPBXIxJN2GcBhYknjd","block_type":3,"heading1":{"elements":[{"text_run":{"content":"Native&Unsafe","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"EjITdi80Qo4ccsxW4QecJzrrnaf","block_type":4,"heading2":{"elements":[{"text_run":{"content":"Native","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"AYQfdVJVzo5XgexAqr5c8yA6nXb","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"在Java中，native方法是一种特殊类型的方法，它允许Java代码调用外部的本地代码，即用C、C++或其他语言编写的代码。native关键字是Java语言中的一种声明，用于标记一个方法的实现将在外部定义。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"SDS2dxw1EodTAwxoInQc7tUOnag","block_type":13,"children":["XCxXdEL7no9NeixEV0mc6MvPnpd"],"ordered":{"elements":[{"text_run":{"content":"生成JNI头文件：使用javah工具从你的Java类生成C/C++的头文件，这个头文件包含了所有native方法的原型。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"1"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"XCxXdEL7no9NeixEV0mc6MvPnpd","block_type":14,"code":{"elements":[{"text_run":{"content":"javah hellojni\n","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}},{"text_run":{"content":"会生成一个hellojni.h文件，c++实现一遍，链接、加载即可","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"language":1,"wrap":true}},"parent_id":"SDS2dxw1EodTAwxoInQc7tUOnag"},{"block_id":"Mh8ZdnT7GoOKxSxCLSqcL5penbh","block_type":13,"ordered":{"elements":[{"text_run":{"content":"编写本地代码：使用C/C++编写本地方法的实现，并确保方法签名与生成的头文件中的原型匹配。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"JOIddD9sIoCtKSx4O4VcfnCbnQd","block_type":13,"ordered":{"elements":[{"text_run":{"content":"编译本地代码：将C/C++代码编译成动态链接库（DLL，在Windows上），共享库（SO，在Linux上）","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"B6OFdfcj2oXWUfxXPgHcUky3nsi","block_type":13,"ordered":{"elements":[{"text_run":{"content":"加载本地库：在Java程序中，使用System.loadLibrary()方法来加载你编译好的本地库，这样JVM就能找到并调用native方法的实现了。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false,"sequence":"auto"}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"XJuOd5CkJoodCOxshrQcK8Wwn3c","block_type":4,"heading2":{"elements":[{"text_run":{"content":"Unsafe","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}},"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb"},{"block_id":"QMGDdKOOQoUgf1xmtC1c4n9snzd","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，Unsafe 提供的这些功能的实现需要依赖本地方法。","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}},{"block_id":"YmpbdhivRoPXUvxAm2jcPHFWnrf","block_type":2,"parent_id":"LxKSdk1s6obNhvxGRUZc8HxenUb","text":{"elements":[{"text_run":{"content":"","text_element_style":{"bold":false,"inline_code":false,"italic":false,"strikethrough":false,"underline":false}}}],"style":{"align":1,"folded":false}}}],"type":"docx"}